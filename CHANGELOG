* 0.30.0

- Value::Error now carries an inner Value instead of an inner ArcStr, allowing
structured error types to be published (mostly for Graphix).
Value::Error(Value::String(..)) is special cased to encoded exactly the same as
it used to in previous versions, so this change is both backwards and forwards
compatible with old code as long as you stick to string errors.

- add Value::Map using a pooled immutable chunkmap. This is mostly for Graphix,
but it's generally useful to have a Value => Value map type that can be
published. Value is forward compatible with previous versions, any value
published by old code will be understood by new code. Value::Map can't be
published to old code, if it is the old Subscriber will fail to read the
Value::Map and gracefully disconnect from the publisher.

- shrink Value to 2 machine words. This is accomplished by boxing DateTime,
Duration, and Decimal, which aren't used often. For the common case of
publishing normal numbers this is worth 5% additional throughput, and for
Graphix it will likely be even more important. This didn't change the wire
encoding of Value at all.

- move memory pooling code (pool module) to a separate (and enhanced) crate
called poolshark

- additional hardening of collection pack implementations to prevent a remote
attacker from being able to trigger fairly large memory allocations in some
cases

* 0.29.2

- use const generics for read_raw so that we can support larger kerberos tokens (up to 64K)

* 0.29.1

- Work in progress version of the tui browser added to netidx-tools

* 0.29.0

- remove the escaping functions from utils and publish them as a separate (and
  enhanced) crate

* 0.28.3

- update deps

- remove all uses of lazy_static from the tree

- split Value out of netidx-netproto into it's own crate
  - it was getting big, so this improves compile times
  - it's useful for external projects that aren't very netidx related

- split bscript into a separate project called graphix (different
  tree). Turns out graphix (nee bscript) is actually bigger than all
  of the rest of netidx put together now, plus it's getting pretty
  general purpose, and as such it deserves it's own project that just
  depends on netidx instead of being part of it.

* 0.28.2

- Update all dependencies

- Fix new subscriptions to the same publisher initial values did not
  batch properly causing an excessive number of batches on large
  initial subscriptions

- Fix excessive memory consumption at call sites in bscript

- Implement recursive parameterized user defined types in bscript

- Various bscript performance optimizations

* 0.28.1

- Fix #20, slow consumers cause publisher to stop for longer than the
  configured timeout

* 0.28.0

- The value type's in memory layout has been reworked
  - Value is now repr C and tag is a u32
  - Value is smaller by 2 words from 5 down to 3
  - Value::Ok has been removed, but the wire format did not
    change. Ok will map to Value::Null.
  - Value::Bool replaces Value::True and Value::False
  - Typ now corresponds directly to the tag of Value, therefore
    getting the Typ of a value is now just reading the tag
  - Value::clone has been optimized. Value tags are now divided into
    two classes. Tags for Copy values grow up from zero, and tags for
    clone values grow down from 0x1000_0000. With a single compare on
    tag clone can either call ptr::read if the value is copy, or
    match and call clone if not.
  - Value::Array now uses memory pools for small arrays to avoid lots of
    small allocations
  - Value::Array now supports zero copy array sub slicing
  - The net effect of all the above changes is to improve throughput in
    the stress test by about 40% (on x86_64).

- The container no longer supports executing bscript. This removed a
  bunch of complex code that I suspect was never used. If you need a
  replacement for executing code in the container, check out the
  bscript shell now included with tools

- bscript dependencies purged from every crate except tools.

- bscript has grown up into a real programming language. This is still
  EXPERIMENTAL, for now you can try it out in the shell subcommand of
  netidx tools. This provides both a repl with completion and api docs
  as well as a script runner. bscript modules have a .bs extension and
  can be executed with e.g.

  netidx shell ~/bin/prog.bs

  This will run until ctrl-c is pressed and continously print the
  value of the last expression in the file as it changes.

- the gtk browser is deprecated and will be replaced in a future
  release

* 0.27.3

- Fix a bug in the recorder that prevented it being used
  embedded. That is, with an embedded data source writing directly to
  the logfile_collection but a publisher attached and serving the
  standard recorder interface.

- Add an embedded recorder test

- Update all dependencies. This turned out to be a bigger deal than it
  usually is

  In particular rustls had major internal and external changes since
  we last updated. During this time it became significantly faster
  than OpenSSL. I haven't evaluated the impact on netidx performance,
  but I'd be shocked if it was negative. Tests of course pass, but do
  keep in mind there was quite a bit of churn caused by the various
  api changes in rustls.

  Updated to the last version of gtk-rs supporting gtk-3. From here,
  it's port the browser to 4 (a major undertaking), or rewrite it
  using something like iced. At this point I'm not sure what the right
  thing is, but whatever it is, it will be a lot of work.

- Fix a bug in the recorder where the recorder would distort the
  recorded batch structure by combining batches that are processed at
  the same time. Proving once again that premature optimization is the
  root of most (all?) evil.

* 0.27.2

- Fix a bug in subscriber that caused spurious empty batches to be
  delivered to an updates channel for subscriptions that aren't
  updating when other subscriptions not covered by that channel are
  updating. Could have had potentially serious performance
  implications in some applications due to lots of spurious
  wakeups.

- Add a recorder session client, for controlling recorders from rust
  with a nice interface.

- Add unit tests to netidx-archive covering logfile_collections and
  the full recorder stack using the new session client interface.

- Fix the tls publish test on windows

- Fix netidx-archive and the recorder on windows. Note, recorder
  archives written on windows must have their filenames translated
  before they will work on unix and likewise for unix to windows.

- Builder pattern for netidx client and server configs

- Builder pattern for recorder config

- Begin testing on aarch64 MacOS again. Pre release we now test on
  x86_64 windows, x86_64 linux, aarch64 linux, and aarch64 Mac OS.

* 0.27.0-0.27.1

- merge #14 refactor netidx-archive so that the origin can directly
  write to an archive collection(s) while exposing the recorder
  interface to netidx.

- update dependencies to more recent versions

* 0.26.0

- Fix a bug in write_with_recipt that could cause concurrent write
  results to be delivered to the wrong request

- This version changes the write protocol, however the change is
  backwards compatible. In order for the bug to be fixed however both
  sides must be running this version or above.

- Merge #10, allow symlinks to archive files

* 0.25.3

- change logfile to use a sorted array instead of a BTreeMap as an index

* 0.25.2

- catch additional cases where the recorder reads more than it should

* 0.25.1

- fix a recorder bug that would case read_deltas to read a lot more
  data than is necessary to fill a request

* 0.25.0

- add recorder rpcs to facilitate an external process writing logs
  while the recorder is used to service readers concurrently

- fix use of deprecated tls function

* 0.24.2

- switch to workspace dependencies and update dependencies

- trim pools in the entire tree

* 0.24.1

- prune over large recorder pools after experiance in production

* 0.24.0

- rpc client constructor is no longer async

- implement a configurable subscription timeout in the rpc client

* 0.22.24

- don't spam the keychain with requests for cert passwords we've
  already asked for

- add a mechanism to populate passwords for certs without consulting
  the keychain or calling askpass

* 0.23.4

- add extensive anyhow context information to the recorder

* 0.23.3

- fix a bug in the way netidx-archive was interpreting index
  lengths. It could cause suprious log errors, as well as false
  positive index hits that would later need to be filtered at
  additional expense.

* 0.22.23

- implement pack for arbitrary sized arrays

* 0.22.22

- fix a bug in pack that would cause decoding an empty length wrapped struct to fail

* 0.22.21

- fix multiple bugs unpacking ArrayString

* 0.23.2

- add *channel::*::Batch::len method

* 0.23.1

- simplify the accept api. Sorry semantic versioning.

* 0.23.0

- channel::Listener::accept and channel::Singleton::wait_connected
  were not cancel safe. This is now fixed but it required a small api
  change, hence 0.23.

* 0.22.20

 - implement convert Chars from CompactString

* 0.22.19

 - implement pack for ArrayString and ArrayVec

* 0.22.18

 - eliminate block_in_place from the netidx crate so that netidx can
   be used on the current_thread tokio runtime. This also applies to
   netidx-protocols, but not netidx-archive or netidx-container

 - fix a memory leak that effects long running publishers that serve a
   lot of different clients. The hashconsing of connected clients was
   not removing unused sets

* 0.22.17

 - implement pack for NaiveDateTime and NaiveDate

* 0.22.16

 - remove unecessary Sync requirement from pool

* 0.22.15

 - implement pack for CompactString

* 0.22.14

 - implement pack for btreemap and btreeset

* 0.22.13

 - add extended auth hook to publisher, allowing the registration of a
   function that can make a final decision on authorization after the
   traditional netidx authentication and authorization steps have been
   completed

* 0.22.12

 - improve error message when a recorder timestamp fails to parse (include the failing timestamp)

* 0.22.11

 - reduce lock contention on large recorders

* 0.22.10

  - add Dval::strong_count

* 0.22.9

  - add Subscriber::is_subscribed_or_pending

* 0.22.8

  - more flexible substitution in recorder script args

* 0.22.7

  - subscribe_interal shouldn't have been public. Sorry!

* 0.22.6

  - fix a race condition in channel registration in subscriber

* 0.22.4

  - add Subscriber::subscribe_updates, subscribe_nondurable_updates,
    subscribe_nondurable_one_updates. These methods allow registering
    for updates as part of the subscription process to avoid any race
    in receiving values.

* 0.22.3

  - add Publisher::events_for_id, that does the same thing as events,
    but only for a specific id.

* 0.22.1

  - fix a memory leak in subscriber that was triggered by lots of
    resubscriptions.

  - implement pack and poolable for indexmap and indexset

* 0.22.0 netidx

  - start using cargo workspaces to manage versions hence the big bump
    to harmonize everything

  - fix a performance regression in tls due to a broken read_buf
    operation in tokio. This was slowing reads down 50x over the
    baseline.

  - optimize packed buffer decoding with a custom buffer
    implementation vs BytesMut

  - optimize varint decoding

  - aside from the regression, which was crushing performance,
    throughput is now 20% better

  - fix a bug in resolver_client::write_client that caused it to
    always write the first publish operation twice.

  - handle additional rare republish cases in
    resolver_client::write_client

* 0.20.3 netidx-tools

  - port the container server to windows

* 0.18.1 netidx-archive

  - fix a date overflow when seeking backwards with an empty current file

* 0.18.2 netidx-derive

  - Check in the proc macro that no tag is used more than once

* 0.18.1 netidx-derive

  - add an attribute #[pack(tag(n))] that allows explicitly specifying
    the on the wire tag of an enum variant. If tag is specified on one
    variant case then it must be specified on all of them.

* 0.19.18 netidx

  - reduce the wait time between resubscription attempts

* 0.20.1 browser, protocols

  - fix borrow error in the browser

  - reduce log verbosity in rpc

* 0.19.17 netidx

  - fix a bug where a dead resolver server could cause publishing to
    take a long time (even if at least 1 resolver in the cluster is
    still alive)

* 0.20.1 protocols and deps

  - remove the lock around rpc procedure calls, it is no longer
    necessary with the new calling convention

* 0.20.0 protocols and deps

  - change the rpc calling convention to fix a race condition where
    the publisher is still publishing arguments when the subscriber is
    created. Now only one published value is required to call an
    rpc. The arguments are sent as a list of pairs to procedure
    instead of as individual argument sets. The rpc server still
    supports the old calling convention.

  - RPC CLIENTS >0.20 CAN'T CALL RPC SERVERS <0.20. Older clients can
    still call newer servers.

* 0.19.22 tools archive

  - the resolver server now runs on windows in a limited capacity, basically
  tls or kerberos mod only

  - fix building netidx-archive on windows

* 0.19.21 tools

  - pull in new archive

* 0.19.15 archive

  - make channel slack configurable

* 0.19.20 tools

  - fix daemonizeing the resolver server (again)

* 0.19.16 netidx

  - resolver server config fixes for tools

* 0.19.15 netidx

  - change the way we use certificates in tls mode

     - the cn is still the string passed to id map for permissions

     - subjectAltName is expected to be a dns name with exactly 1
       entry, this is used as the server name

     - this should be backwards compatible with what we were doing
       before, because rustls always required subjectAltName to be
       specified. So the main change is the CommonName can be anything
       now.

  - implement additional id mappers, specify id_map_type in the config

     - DoNotMap: don't map ids at all, just use the raw string. In the
       case of kerberos this will be the user principal name of the
       user. In the case of tls this will be the common name on the
       certificate. In the case of local this will be the uidnumber of
       the user.

     - Command: The previous behavior, id_map_command will be called
       to translate the raw user into a set of users/groups. This is
       the default

     - Socket: The id_map_command string must be specified and should
       be the path to a listening unix domain socket. The resolver
       will connect to the socket and write the user name followed by
       a newline. It will expect the server to write the response in
       the same format as /usr/bin/id and then close the socket.

  - implement id_map_timeout in the config which is the number of
    seconds to cache id map entries before they must be done
    again. The default is 1 hour.

* 0.19.14 netidx

  - public tls function to precache key passwords in the keychain

  - trim cr and lf from passwords read from askpass

* 0.19.13 netidx

  - more config file path exposure

* 0.19.12 netidx

  - make some more functions public

* 0.19.11 netidx

  - make the tls module public

* 0.19.10 netidx

  - move a bunch of path related functions into file::Config from
    Config.

* 0.19.9 netidx

  - make the client config file types public

* 0.19.19 tools

  - fix bug that caused daemonized resolver server and activation
    server to fail.

* 0.19.5 protocols 0.19.8 netidx

  - add more context to channel errors

  - fix a race in connect_singleton

  - add publish_with_flags_and_writes to eliminate a race between
    publishing and registering a write channel.

* 0.19.14 archive

  - don't call get if the file exists

  - don't hold the lock while opening the archive file in LogfileCollection

* 0.19.13 archive

  - further minor optimizations

  - reimage should also take a filter

* 0.19.12 archive

  - cache open archive files for some time

  - only reindex a shard's directory when it is necessary

  - faster index reading and writing

* 0.19.11 archive

  - derive debug and clone on the recorder_client::Client struct.

* 0.19.10 archive

  - fix a bug in the oneshot rpc. It now returns results by shard with
    a pathmap to interpret the results by shard.

  - implement disjointness checking for globset. Use it to not start
    oneshot or publisher tasks that can never match the user's filter

* 0.19.9 archive

  - don't compress the index for an additional 2x and a reduction in
    complexity.

* 0.19.8 archive

  - introduce index headers to batches. the index header contains a
    list of all the ids in the batch. now you can read_deltas with a
    filter hashset of ids you are interested in and it will
    automatically skip decoding batches that didn't contain any of
    them. Factor of 3.5x faster when looking for a specific thing that
    isn't that common in a large compressed archive.

  - fix an O(n^2) length check in oneshot for an 80x improvement on
    reading a 150 MB compressed archive. oops.

* 0.19.7 archive

  - big netidx-archive refactor. now shards can be represented
    internally as well as across processes. There are a lot more
    reasons to shard than record performance (e.g. playback latency is
    a big one), so it makes sense that the recorder should be able to
    shard using internal tasks on a single machine. The cluster
    mechanism is still available, but is meant to be used when you are
    sharding across multiple machines.

* 0.19.6 archive protocols

  - lots of fixes for timing and clustering

  - cluster moved over to pack. technically this broke semantic
    versioning.

  - add a pack implementation for Bound

* 0.19.5 archive

  - fix bug in load_file_header

* 0.19.4 archive

  - allow tuning of the parallel window size

* 0.19.3 archive

  - The container server lost the ability to compress it's
    database. This is because sled hasn't been updated in ages and
    depends on an ancient version of zstd. If it gets updated I will
    readd that functionality.

  - Add transparent zstd decompression to the recorder. The archive
    files can now be compressed with netidx record-client compress and
    it will decompress the data as needed.

  - Add a bunch of command line tools for working with archive files
    - netidx record-client dump
    - netidx record-client verify
    - netidx record-client compressed
    - netidx record-client compress

  - Fix a number of bugs in the recorders

* 0.19.6
  - don't spam info messages when republish fails

  - pool the republish Vec

  - the browser should take the configured default_auth into account

  - properly check the exit status of commands in the recorder

* 0.19.5
  - fix a bug in subscriber that could cause the last messages from
    a disconnected publisher to be lost

  - browser force new netidx version

  - add a command line tool to query the recorder's oneshot facility

* 0.19.4
  - fix a bug in subscriber that caused voluntary shutdowns
    to add the ip to the recently failed list.

* 0.19.3
  - fix a bug in PREFER_LOCAL that could prevent subscribing

* 0.19.2
  - implement new publish flag FORCE_LOCAL, which overrides USE_EXISTING
    but is otherwise the same as PREFER_LOCAL.

* 0.19.1
  - fix a bug in PREFER_LOCAL

  - introduce a new replay mode in the recorder "oneshot" that lets
    you just call an rpc with a time range and get data.

* 0.19.0
  - fix PublisherBuilder to be more ergonomic, sorry for the churn

  - add a parameter `slack` that together with the flush timeout can
    be used to properly manage the slow client problem.

* 0.18.3
  - add new publish flag PREFER_LOCAL, which will cause subscribers to
    try addresses in the following order.
    - 1st addresses that are on the local computer
    - 2nd addresses that are on the same subnet as the local computer
    - 3rd all other addresses

  - swap out get_if_addrs crate for the maintained if-addrs crate

* 0.18.1-2
  - add features to BindCfg for NAT traversal. You can now run publishers
    and resolver servers behind a NAT and DNAT forward the port.

  - Fix a bug in TLS, sometimes (rarely) it is required to call flush on
    tls wrapped sockets, because they are after all buffer io. Oops. Thank
    you weird aws nat thing for helping to find this bug :-)

  - 0.18.2 just removes some dbg statements I left in. Sorry!

  - browser sort table rows and columns by their numeric value if they parse
    as integers.

  - recorder, stop polling dead subscriptions after trying for a while, increase
    the batch buffer size in case the recorder thread is temporarially delayed.

* 0.18.0
  - Change pre allocated packed data structures to avoid TooBig errors
    and still allocate safe quantities of memory.

  - change move the core of the recorder to netidx-archive

  - the recorder can now rotate it's log file periodically, and can
    serve a directory of log files transparently to clients. There are
    optional shell hooks the archiver can call out to announce new log
    files, list log files, and get log files from some kind of long
    term archive.

  - the recorder now uses a config file instead of command line
    arguments, it was just getting too complex to manage the
    arguments. running with --example will print an example
    config. Sorry for the breakage.

  - the recorder archive format is unchanged, but the file layout is
    different. The recorder uses a directory, which it will create if
    it doesn't exist. The current log file is always called
    "current". Historical log files are called the rfc3339 timestamp
    when they ended. Again sorry for the breakage.

  - update to biflags 2.0.

  - implement serialize and deserialize for pooled

  - change the websocket proxy protocol to expose batching

  - implement poolable for triomphe::Arc

  - fix overflow in pack decoding found in fuzz testing

* 0.17.4

  - ignore pings in netidx-wsproxy

  - add serialize/deserialize to netidx-netproto::value::Typ

* 0.17.3

  - add a pack implementation for HashSet

  - don't put empty objects back in pools

* 0.17.2

  - implement debug on Publisher

  - change the websocket proxy protocol a bit to make it possible to
    have multiple in flight rpcs.

  - Allow rpcs to complete out of order, and don't wait for them to
    move on

  - Fix trait requirements for Packing HashMap

  - implement a new toplevel Pack directive #[pack(unwrapped)]
    which prevents length wrapping the type it is applied to.
    Also the Pack macro now validates attributes.

  - websocket-proxy; expose the warp filter that runs the proxy so
    it can be combined into a bigger warp api if desired.

  - change netidx-archive to use the better maintained memmap2 crate
    instead of mapr

* 0.17.1

  - permissions now allow dynamic params. e.g.  { "/foo/bar/$[user]":
    { "$[user]": swlpd } } would give user 'eric' swlpd in
    /foo/bar/eric. { "/foo/bar/$[group]": { "$[group]-admin": swlpd,
    "$[group]": sl } } would give members of group 'users' sl in
    /foo/bar/users, and members of group 'users-admin' swlpd in
    /foo/bar/users.

  - add a new tool and library, netidx-wsproxy, a websocket proxy to
    publisher, subscriber and rpcs. Including an example javascript
    interface.

* 0.17.0

  - netidx_derive::Pack implement #[pack(other)] attribute for
    enums. Does the same thing as #[serde(other)], if the enum tag
    isn't know will decode as the enum #[pack(other)] is placed on.

  - fully propagate user and group info from the resolver through to
    the publisher. Now for all authentication mechanisms, the
    publisher will be able to return a UserInfo struct that contains
    the name, primary group, and groups of a connected user. This will
    only work if all components are running 0.17 or later, previous
    versions will work, but won't provide user info.

  - implement pack for three tuples, and four tuples.

  - update the browser to the latest version of gtk-rs, and make use
    of the finally upstreamed gktsourceview4 subclassing

* 0.16.0-9
  - Fix a bug in subscriber that could cause pushback not to work at
    very high message rates

  - implement better batching in channel recv. Pack channels are now
    capable of sending 1 GB/s of u64s locally on a 1260P, and the
    latency of sending 1000 u64s to and from a receiver on the same
    host is 39us in the 90th percentile.

  - implement try_recv, try_recv_one in both kinds of channel

  - add a pack implementation for usize, Result, Arc, Box,
    anyhow::Error, atomic_id, smallvec, and enumflags2

  - introducing netidx-derive, a crate for netidx derive macros. The
    first of which is #[derive(Pack)]. Pack is netidx's native binary
    encoding format. Initially it was implemented by hand, but now it
    can also be implemented using the derive macro. Happy packing!

  - most existing protocols in netidx-netproto changed to use the proc
    macro. With the exception of Value, which does some custom stuff.

  - a couple of convenience methods in value and rpc

  - change publisher::{publish, publish_with_flags, update,
    update_subscriber} take Into<Value> instead of a direct
    value. Implement try_ variants of update and update_subscriber
    that take TryInto<Value>.

  - call_rpc can now take any TryInto type as an argument

  - I may have slighly broken semantic versioning here, but 0.16 just
    released, so I don't think it's a huge deal.

* 0.16.1 and 2

  - improve the safety of len_wrapped_decode

  - add a pack implementation for UUID

  - remove krb5_iov as a default feature

  - make clientparams cloneable, and make load take a reference
    instead of an owned value.

* 0.16 all
  - rename Subscriber::durable_subscribe -> Subscriber::subscribe

  - rename Subscriber::subscribe -> Subscriber::subscribe_nondurable

  - rename Subscriber::subscribe_one -> Subscriber::subscribe_nondurable_one

  - protocol version 3 changes the wire format to introduce additional
    extensibility. Unfortunatly version 3 isn't backwards compatibile
    with version 2. I decided to do this now, as it may be the last
    chance.

  - Introducing netidx channels. Bidirectional message channels that
    function like tcp sockets, except the address is a netidx path

  - Major refactor of publisher and subscriber to completely eliminate
    blocking awaits from their respective message handling loops.

* 0.15.1 core netidx

  - expose the inner u64 in atomic_id for ffi bindings
  - make DesiredAuth Serializable/Deserializable for ffi bindings

* 0.15.1 browser

  - fix a crash when creating progress bars. sorry ...

* 0.15 all

  - skipping ahead to 0.15 because tls is a big step forward.
  - add a new authentication mechanism TLS, for using transport layer
    security for authentication and encryption.
    - using rustls
    - full mutual authentication is REQUIRED. Later I may add PublicTls
      for server -> client only authentication. We'll see.
    - The protocol changes are backwards compatible, but obviously old
      publishers, resolvers, and subscribers will not understand tls.
    - At the moment it's all or nothing at the resolver level. You can't
      do kerberos AND tls on the same resolver. There's no reason this
      couldn't be done, however I don't need it right now, and I wanted
      to release the MVP.
    - The book is updated for tls in all the relevant places
  - RPCs are reworked on the server side and a bit on the client side.
    The new api is a significant improvement IMHO, but it will break all
    rpc servers *sorry*. However the protocol did not change significantly,
    so existing rpc clients can call new rpc servers, and new rpc clients can
    call old rpc servers.

    The only thing that did change about the rpc protocol is that there is now
    only one way to get a reply to your procedure call, by using write_with_recipt.
    That is what the rpc client always did, so it will continue to work, however if
    you were manually calling rpcs and depending on the procedure value to update it
    won't do that anymore.

* 0.12.7 browser

  - Use the new bscript functionality to greatly improve tracing. Load
    existing traces when opening the expression inspector. Use the
    bscript vm's timestamps.

  - Make tracing a menu toggle per window, which is on by
    default. Tracing is fairly light weight, but if you have a
    debugged view that you want to run a little bit faster you can
    turn it off.

* 0.14.0 bscript

  - record initialization events

  - add a bunch of new functions to the debug context api

  - change the types given to watches

  - timestamp events when they happen

* 0.12.5 tools

  - Fix a bug in the archiver that would cause it to hang on to idle
    sessions if any client was using any session. Now it will drop
    sessions that no client is using after 1 minute, as was the
    original intention.

* 0.12.6 browser

  - Fix paned widget is jumpy when moving the mouse until manually
    moving the boundry under some gtk themes

* 0.12.4 netidx

  - Fix an issue with the resolver server that could result in
    leftover paths from a dead publisher being associated with a new
    publisher when using local authentication.

* 0.12.5 browser

  - Fix crash that could occurr due to trying to get the adjustment of
    a destroyed scrolled window.

* 0.12.4 browser

  - put the breadcrumbs in a scrolled window so that they don't force
    the browser window size to increase when viewing a deeply nested
    path.

* 0.12.3 netidx

  - add a helper to publisher required by netidx-dbus

* 0.12.3 browser

  - Greatly increase the utility of the event log window in the
    expression inspector. It now shows only actual events. It shows
    the event that happend, the expression the received the event, and
    the value emitted by the expression.

  - Fix some cases where degenerate bscript code could hang the
    browser. It's still possible, but it's much harder now.

  - Improve the performance of normal bscript execution by only
    recording debug events when the editor window is open.

* 0.12.2 browser netidx

  - Fix some borrow error crashes that could occurr when a publisher
    is hung while accepting a write generated by a view save and the
    user tries to navigate away.

  - Fix a bug that could cause rpc calls to silently fail in the
    background.

  - Don't hang the entire async back-end if waiting for a file save, a
    save to netidx, or a table resolution.

  - change the sematics of many bscript operations such that now they
    do not produce a result until all of their arguments have been
    resolved. This prevents spamming partial results, and is probably
    what everyone expectes to happen when they write sum, product,
    divide, etc. With the exception of any, all bscript primitives
    should now function this way.

  - Eliminate all the unsafe code in bscript stdfn. It was safe IMHO,
    but the minor performance win was just not worth the risk.

  - minor improvement to the error messages produced by subscriber
    when it fails to subscribe because the connection to the publisher
    died.

* 0.12.2 tools

  - separate the tools lib from tools so external users don't need to
    pull in all of tools deps in order to use the common command line
    arguments

* 0.12.1 netidx

  - add support for aliases in publisher and subscriber. Aliases allow
    publisher to publish the same data under multiple names without
    the overhead of publishing the data twice. The only overhead is an
    extra name in the resolver, and the publisher. Subscriber needed
    to be aware of this, so if you plan to use aliases you must
    upgrade your subscribers first.

    Subscribing to an alias pointing to an existing subscription is
    functionally the same as subscribing to the same path twice, you
    just get a clone of the existing subscription.

* 0.12.0 all components

  - fix a resolver client bug that prevented local publishers from
    republishing after the local resolver was restarted.

  - work around some gtk themes (breeze) causing data not to update in
    the browser unless the user forces events to happen. Breeze still
    does strange things to gtk treeview, but at least it displays
    updates properly now. I guess libadwaita can't come soon enough.

  - add the ability to publish aliases. Aliases are very lightweight
    as they do not duplicate any of the internal data structures in
    either the publisher or the subscriber. Subscribers older than
    0.12.0 may behave strangely if they subscribe to the same value
    twice through an alias, therefore if you plan to deploy aliases
    you should upgrade all subscribers to 0.12 or later first.

* 0.11.1 tools

  - fix building the tools on windows

* 0.11.0 all components now go to 11

  - introduce protocol version 2, not backwards compatible with
    version 1. Sorry

    - vastly compressed resolves, resolving a lot of things should use
      much less bandwidth now

    - fix GSSAPI negotiation. This is why v2 is incompatible with v1,
      the change was just too large to work around

    - Add local authentication mechanism, and make authentication
      mechanisms extensible so we can add more in the future without
      another protocol version

  - local machine resolver servers with local authentication
    mechanism. For dev workstations. For desktop apps using the
    browser

  - container server is now a library (as well as a server), it's a
    good basis for some kinds of applications

  - various long standing resolver server bugs fixed (removing default
    publishers, and a list bug)

  - major browser improvements, new widgets, bug fixes, new bscript
    builtins

  - resolver server and client configuration files separated

  - updated book

    - all browser widgets documented

    - updated administration and quick start sections for 0.11

    - reorganized examples

* 0.10.5 browser, netidx, netidx-tools, bscript, protocols

  - bump dependencies for all modules

  - implement context sensitive completion in the browser expression
    inspector windows. It is able to suggest completions for built in
    functions as well as variables that are in scope. Use CRTL+Space
    to trigger it.

* 0.10.4 netidx, netidx-tools, bscript, protocols

  - use cross-krb5 instead of gssapi and winapi directly
  - fix build on mac os

* 0.10.3 netidx-tools

  - fix building on windows, which has been broken for some time due to
    new tools that require unix, sorry!

* 0.10.0-0.10.2

  - Add arrays to the value datatype. This has some pretty big
    implications,

    - Values are now compound structures, and could be used to
      represent many different kinds of data. e.g. records, matrices,
      trees, maps, just to name a few. It's still recommended that
      users publish additional simple values instead of making
      everything a compound value, however there are cases where
      arrays really make things a lot clearer.

    - The shell tools and bscript now share a parser/pretty printer,
      and as such the shell tools can now parse and print arrays just
      like any other value. The syntax for an array value is [ v0, v1,
      ... vn ], where each value is type prefixed.

    - bscript can now handle arrays, and the view definition has been
      updated to use them where they make sense.

    - old publishers can talk to new subscribers, and new publishers
      can talk to old subscribers as long as they don't use arrays. In
      case they do, the old subscriber should not crash, however it
      won't be able to read the array data.

* 0.9.1 bscript, tools, browser

  - fix the "do" bscript function which was broken, and fix it's
    semantics to match documentation (return the value of the last
    expression instead of nothing)

  - fix a bug in the container that could have resulted in subtrees
    being erroniously deleted. If the user deleted a nested root, the
    container might not have recognized that the subtree had a parent
    root, and would then have deleted it. This has been corrected.

* 0.9.0 netidx, netidx-tools, netidx-browser:

  - Subscriber uses much less memory, a durable subscription now costs
    about 2x a publish of the same value, which is a lot better than
    it has been in the past.

  - Subscriber durable resubscriptions reworked, now we will
    resubscribe in batches of up to 100K instead of just unleashing a
    horde of resubscriptions if the publishers get
    behind. Resubscribing to large numbers of things (e.g. 10 million)
    is now much smoother.

  - Subscriber message rates are about 24% faster unencrypted, and
    about 12% faster encrypted on x86_64 (Skylake). 18% faster
    encrypted on OpenPOWER.

  - Publisher API reworked unfortunatly these are BREAKING
    changes. The rework is meant to solve three problems with the
    previous api.

    - most serious, you had to remember to call flush after updating
      values, if you forgot, nothing would be sent. Now there is a
      structure marked with must_use so you can't accidentially forget
      to flush updates.

    - It wasn't possible with the old api to have concurrent tasks
      using the same publisher but retaining control of their own
      batching. This meant that it was sometimes necessary to create
      separate publishers within the same process just to get control
      of the grouping of updates (e.g. in the recorder).

    - The use of SocketAddr as a unique id for a client was dangerous,
      it has been replaced everywhere with a unique id.

    - The API change had the unintended, but welcome, consequence of
      reorganizing the code and improving performance by a fair bit

      - 32% faster message rates on OpenPower (POWER 9), I think due
        to decreased use of atomic data structures that are not well
        optimized for the platform. Now POWER 9 performance lines up
        much better with other benchmarks vs x86_64 and ARM64.

      - 17% faster message rates on ARM (A72) and x86_64 (Skylake)

      - 20% less memory per published value

  - Publisher advertisements, a middle way between a sparse namespace
    and a fully published one. Uses less memory than a full publish
    but looks identical to subscribers.

  - Paths are now based by ArcStr instead of Arc<str>, this saves 1
    word per path, and makes Path::clone slightly cheaper. This can
    add up to a significant memory savings in the resolver server or a
    large publisher/subscriber (e.g. 10 million paths costs 800 MiB
    less after this change).

  - Documented the rpc module.

  - the rpc protocol now allows procedure arguments to be specified
    multiple times. The server side will receive a list of all values
    specified for each key.

  - the rpc client now includes internal synchronization to prevent
    errors when the same procedure is called concurrently from the
    same subscriber instance.

  - fix: in bscript multiple concurrent rpc calls to the same function
    could result in return values getting mixed up or duplicated.

  - added CALL command to call an RPC from the subscriber command line
    tool.

  - new tool, container, a persistant, bscript enabled, value
    store. Kinda like a distributed spreadsheet. Kinda like a nosql
    database server. Kinda just it's own thing. Using sled for
    persistant storage.

  - the bscript call function now takes a trigger argument. The rpc
    will only be called when the trigger argument updates, or once
    initially if the trigger has a current value. This allows much
    easier use of the call function in event handlers.

  - Fix additional resolver server bugs related to removal of default
    publishers. Due to protocol changes 0.9 publishers require a 0.9
    resolver server if they use the default publisher feature. Old
    publishers will still work with the 0.9 resolver server, however
    if they use default publishers it is recommended to recompile
    against 0.9.

* 0.8.1 netidx, netidx-tools:
  - fix a bug in the resolver server which would cause it to hang on
    to default publishers until the process is restarted even if the
    publisher itself timed out or explicitly sent clear. This bug was
    caused by the sharding implementation, and would effect the
    default configuration. Only the resolver server needs to be
    upgraded to fix this bug, it is backwards compatible with
    everything 0.8.0 was compatible with. Publishers and subscribers
    can keep using 0.8.0, nothing changes for them. Parallel
    programming is hard even in rust, sorry :-(

  - added a test to check default publisher functionality, including
    that it goes away!

* 0.8.0 netidx, protocols, netproto, tools, browser:
  - The command line publisher can now accept writes, simply say
    WRITE|PATH to enable writes for PATH. Written values will be sent
    to stdout in the same format as the command line subscriber. PATH
    will be published with a value of null if it hasn't been published
    previously

  - Crate cleanup: netidx-protocols was split into 3 crates
    - netidx-bscript: The bscript parser, and vm implementation
    - netidx-archive: The archive file reader/writer library
    - netidx-protocols: Actual protocols built on top of netidx

  - the big bscript refactor: The bscript VM along with the
    implementation of the core of the language was moved out of the
    browser and combined with the parser, which was moved out of
    netidx-protocols to form netidx-bscript. Now it should be possible
    to use bscript in other projects besides the browser, and I have
    one planned soon. No semantic changes were intended as a result of
    this refactor.

  - table is now bscript enabled. Path, default sort column, default
    sort direction, filter mode, and the filter are now set by bscript
    expressions instead of hard coded in the editor.

    Moreover, tables can be made editable, and three new events are
    exposed to make this useful,

      - on activate: allows you to control what happens when the user
        double clicks a row, or presses enter if the table isn't
        editable. event() produces the path of the row, and the
        default expression is, navigate(event()), which does the same
        thing the browser does now.

      - on select: updates when the user selects a cell, event() is
        the path of the newly selected cell.

      - on edit: updates when the user edits a cell, event() is the
        new value.

  - Implemented new wigets, linkbutton, frame, paned, and notebook.

  - API change, the return value of Subscriber::subscribe is now a
    FuturesUnordered collection instead of a Vec. This allows
    applications to get subscriptions as they individually complete
    instead of being forced to wait until the entire batch is
    done. The old behavior can be easily replicated by just calling
    collect (from StreamExt in futures-rs) on the returned stream.

  - Major refactor of durable subscriptions. Previously the durable
    subscriber kept track of one outstanding batch of subscriptions at
    a time. This meant that if one of the publishers in the batch was
    hung, or just slow, subscriptions would have to wait until it's
    timeout expired to be processed.

    Now the durable subscriber can keep track of any number of
    outstanding subscribe batches, and more importantly, it will
    process every subscription individually as soon as it resolves. So
    now if a publisher hangs, it won't become a poisioned chalice that
    slows down subscriptions to unrelated publishers.

* 0.7.3 netidx-tools:
  - Additional error handling fixes in the recorder.

* 0.7.2 netidx-tools:
  - Make the recorder more robust to transient resolver server
    failures.

* 0.7.1 netidx-tools:
  - Add the DROP command to the command line publisher to stop
    publishing a path
  - Add oneshot mode to the subscriber
  - Add no-stdin mode to subscriber
  - Add a subscriber option to abandon a subscription if it doesn't
    succeed before a passed in timeout
  - Subscriber will now automatically subscribe when you write, and if
    a write is queued it will tell you how many writes are in the
    queue for a given path

* 0.7 netidx, netidx-tools, netidx-browser, netidx-protocols:
  - major update to the filter language syntax and semantics
  - add netidx rpc to protocols, use it in the recorder, implement it
    in the browser formula language
  - add the ability for the publisher to set flags on a published path
    in the resolver server. Implement a flag to force subscriber to
    use an existing connection where possible instead of picking a
    random publisher address. Use this flag to handle multiple
    publishers of the same rpc, and the control interface in the
    recorder. This protocol change requires the resolver server to be
    updated, but is backwards compatible with older clients.

* 0.6.1 netidx netidx-tools netidx-core:
  - small semantic change in subscriber, writes to a dval now queue
    when the subscription is not connected and are sent on
    reconnect. Previously they would be dropped.
  - Fix recorder hang when setting state to play when it's tail
  - Put limits on the number of sessions allowed per client and total,
    and pick reasonable defaults.
  - add a few support methods to netidx core

* 0.6.1 browser:
  - Fix several really dumb bugs in the formula parser
  - Fix the browser's formula inspector closing whenever you change
    something
  - Fix the browser's formula inspector sometimes shows stale values
  - Fix the evaluation of the any() formula so it also works with
    constant sources

* 0.6.0:
  - New tool, netidx recorder, records subscriptions to compact
    archive files and publishes archive files.
  - Add list_matching and check_changed methods to ResolverRead. Both
    methods can't be used with older resolver servers, however older
    clients can still talk to a newer resolver server.
  - Plug a couple of holes that could allow non canonical paths to be
    created
  - Fix a bunch of bugs coming from an incorrect test for path
    parenthood. Including a potential referral loop with a complex
    cluster.
  - Change the len and const_len method names of Pack to encoded_len,
    and const_encoded_len to avoid confusion.
  - Implement From on Value for most primitive types.
  - Add a trait, FromValue, that behaves like FromStr, and implement
    it for many primitive types. Refactor cast_* methods into
    cast_to::<T> where T: FromValue.
  - Tune the resolver server to give much higher priority to Resolve
    over List, Table and especially ListMatching calls.
  - Reorganize the project so rust-analyzer will work on all the sub
    projects.
  - Allow the option in subscriber to stop storing the last value
    received for about 12% improved performance on Intel (on ppc64le
    it's worth something like +50%).
  - command line 'resolver list' now takes globs, and can poll for
    changes
  - Implement a write dialog in the browser table view.
  - Move to Tokio 1.0 and Bytes 1.0

* 0.5.1:
  - Resolver server: improve the performance of sharding (eliminate
    integer division) for a noticable speedup processing large
    batches.
  - Put an upper bound on total pool size to avoid various extreme
    scenarios causing unbounded memory usage.
  - Pool more buffers in the resolver server to reduce dynamic
    allocation.
  - Fix a bug in the new sharded resolver store that broke default
    publishing.
  - Fix unit tests.

* 0.5.0:
  - Update to tokio 0.3 aka 1.0
  - Implement timeout logic in the resolver client to deal with the
    case where a resolver server is hung. The rule is, minimum timeout
    15 seconds or 6 microseconds per operation in the batch for reads
    and 12 microseconds per operation in the batch for writes,
    whichever timeout is longer.
  - Limit reads and writes to a maximum batch size to prevent doing
    too much work at once on a tokio worker thread, and reader/writer
    starvation, The max batch sizes are are 1000K ops for readers and
    100K ops for writers. Cleaning up dead publishers are included in
    these limits. Results are flushed back to the client after each
    chunk so that we interact properly with the hang detection feature
    mentioned above.
  - The resolver now uses all cores for reads and writes, and no longer
    uses locking, instead the database is sharded internally with each
    CPU controlling a shard. Batches are hashed by path and sent out
    to their corresponding shard (or all of them in the case of
    e.g. list). Performance for large publishers and/or lots of
    publishers on machines with a lot of cores is vastly improved.
  - Improve a degenerate case in resolver_store when lots of
    publishers publish the same paths. It's still N^2, but the
    constants are much better, and it's now not an issue to get to
    thousands of publishers publishing the same set of paths, probably
    more than you'd ever want in practice.
  - Fix a bug in the resolver client that would cause a long running
    write connection to stop after the heartbeat interval.
  - Fix a design flaw in the secstore. Now it will always keep the
    security context around for a publisher for as long as that
    publisher is alive.
  - Caching of read security contexts is no longer supported after I
    found that some (older) implementations of kerberos hold an open
    file per ctx for the replay cache. Since we must keep a live ctx
    for each live publisher you may need to raise the allowed number
    of open file descriptors to avoid starvation if you use an
    effected kerberos distribution. The number of open files should be
    at least P + 2*C, where P is the number of publishers and C is the
    number of allowed simultaneous connections. Alternatively you can
    disable the replay cache by setting KRB5RCACHETYPE=none. This is
    not recommended as it opens you to token replay attacks.
  - Fix a bug in the resolver server connection tracking logic that
    caused the number of counted open connections to be higher than
    the actual number when the counted connections are live publishers
    that are heartbeating but not actually connected. This could cause
    read and write starvation with a large number of publishers.
  - No longer fail publisher flushes when the publisher can't reach
    any resolver server, instead log the error and keep trying
    forever. There is just no combination of timeouts and or logic
    that seems better. The means that publisher::flush now cannot fail.
  - Fix a bug in publisher that would cause new published names not to
    be sent to the resolver if they are queued while a flush operation
    is in progress.
  - NO protocol changes in 0.5, it's safe to mix any 0.5 with any 0.4
    component. The major version bump is due to tokio 0.3 being a
    potentially large change.

* 0.4.2:
  - Fix browser design mode widget highlights are wrong when there are
    nested grids.
  - Maybe fix an intermittant issue with design mode where invisible
    widgets are still interactable in the properties view and the
    visible widgets are not.
  - Make the WIP book the homepage

* 0.4.1:
  - Fix browser can't get out of raw mode.
  - Subscriber: Tweak the semantics when registering a duplicate
    channel for updates on a subscription. Now, if begin_with_last is
    true, the duplicate channel will receive an update with the current
    state even though the registration will be ignored.
  - Reduce allocation in the command line publisher.
  - Fix a bug in the resolver store that would result in ghost columns
    remaining in the browser even after data was removed. Enhanced
    tests to cover the columns method.
  - Fix a bug in resolver store that would result in a list of a path
    with a trailing slash recursively listing all children. While this
    might seem useful it wouldn't work in a hierarchical cluster, so
    the easiest thing to do is remove it. In any case for a large
    server it could be quite a bit more dangerous than a simple list,
    especially if triggered accidentally.
  - Change the way null is published in the shell publisher such that
    it is possible to publish a string "null", sorry :facepalm:.
  - Fix subscriber connection might decide it's idle and disconnect
    when there are pending subscription requests in it's
    queue. subscriber will now disconnect immediatly when the last
    subscription is unsubscribed and there are no queued
    subscriptions.

* 0.4.0:
  - protocol breaking changes (additions). 0.4 will be the last non
    backwards compatible protocol, from here on protocol breaking
    changes will introduce a new protocol version, and new library
    versions will be able to speak to old clients using at least one
    protocol version less than the current one.
  - allow publisher to unicast to specific subscribers
  - writes can return success or failure instead of silently eating
    errors. This behavior is not mandatory, as it has a performance
    impact.
  - netidx browser is now a separate binary from the tools
  - netidx browser "views", publishable and editable custom guis
  - subscriber will notify explicitly when a subscription is
    unsubscribed. This imposes minimal to no overhead due to rust
    being awesome
  - simplify durable subscriber, shrink it's memory usage a couple of
    words per subscription
  - eliminate a race between durable subscriber subscription state and
    updates. Facepalm averted.
  - add many useful value types, e.g. Result, DateTime, Duration
  - It is now possible to build on Mac OS by disabling the (default)
    krb5_iov feature. This will result in reduced performance when
    talking to encrypted services, but it works.
  - netidx-protocols breaking. View definitions are not backwards
    compatible with 0.3, and given how much development is going on in
    the browser I would expect more breaking changes to view
    definitions for a while. At some point it will settle down, and I
    will start to version that protocol just like the
    resolver/publisher protocol, but for the moment it's much easier
    to just move fast and break it.
  - various improvements to the command line tools, some of which are
    breaking changes. e.g. publisher and subscriber write now take a
    triple of path, type, value, instead of path, value.

* 0.3.2:
  - minor api enhancement. add update_changed, and current to
    publisher::Val

* 0.3.1:
  - make publisher::Id public again, sorry!

* 0.3.0:
  - basic netidx browser added to tools, more is planned for it
  - protocol not compatible with previous versions
  - subscriber Val::last and Dval::last are no longer async

* 0.2.0:
  - trim tokio features to the required set
  - config in dns is removed due to limitations, which is really sad
    because it was damn cool
  - reduce buffer slack
  - fix a few cases where we didn't set tcp nodelay
  - many windows releated bugs fixed
  - test extensively on windows
  - protocol not compatible with previous versions

* 0.1.2:
  - Experimental support for publisher/subscriber on windows

* 0.1.1:
  - Fix some bugs

* 0.1.0:
  -Initial release
