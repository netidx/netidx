use tui;
use tui::table;
use tui::block;
use tui::input_handler;

let path = "/";
let gutter = style(#bg:`Indexed(235), #fg:`Cyan);
let (mode, structure) = select net::list_table(path) {
    { columns, rows } => {
        let mode = uniq(select columns {
            [] => `List,
            _ => `Table
        });
        let columns: Array<string> = select array::map(columns, |(col, _)| col) {
            [] => ["Value"],
            cols => array::sort(#numeric:true, cols)
        };
        let rows: Array<string> = {
            let base = select str::dirname(rows[0]?) {
                null as _ => "/",
                s => s
            };
            let names = array::filter_map(rows, |r| str::basename(r));
            let names = array::sort(#numeric:true, names);
            array::map(names, |name| select base {
                "/" => "/[name]",
                base => "[base]/[name]"
            })
        };
        (mode, { columns, rows })
    }
};
let size: Size = never();
let selected = { x: 1, y: 0 };
let viewport = { x: 0, y: 0 };
let visible_rows = {
    let len = array::len(structure.rows);
    let start = min(len - 1, viewport.y);
    let end = min(len, viewport.y + size.height - 1);
    (structure.rows)[start .. end]?
};
let { total: _, cols: visible_columns, widths }:
    { total: i64, cols: Array<string>, widths: Array<Constraint> } = {
    let init = { total: 4, cols: [], widths: [`Min(4)] };
    array::fold((structure.columns)[viewport.x ..]?, init, |{total, cols, widths}, col| {
        let len = str::len(col);
        select max(10, len) + total {
            l if l <= size.width => {
                total: l,
                cols: array::push(cols, col),
                widths: array::push(widths, `Min(len))
            },
            _ => {total, cols, widths}
        }
    })
};
let header = select mode {
    `List => row(#style:gutter, [cell(line("Name")), cell(line("Value"))]),
    `Table => {
        let cols = array::map(visible_columns, |col| cell(line(col)));
        row(#style:gutter, array::push_front(cols, cell(line("Name"))))
    }
};
let selected_path = {
    let row = visible_rows[selected.y]?;
    select mode {
        `List => "[row]",
        `Table => "[row]/[visible_columns[selected.x - 1]?]"
    }
};
let rows = array::map(visible_rows, |row| {
    let name = select str::basename(row) { null as _ => "", s => s };
    &tui::table::row(select mode {
        `List => [
            cell(line(name)),
            cell(line("[any(uniq(row) ~ "#SUB", throttle(net::subscribe("[row]")))]"))
        ],
        `Table => {
            let a = array::map(visible_columns, |col| {
                let path = "[row]/[col]";
                let v = any(uniq(path) ~ "#SUB", throttle(net::subscribe(path)));
                cell(line("[v]"))
            });
            let name = cell(#style:gutter, line(name));
            array::push_front(a, name)
        }
    })
});
let command_error = never();
let run_command = |c: string, path: string| {
    let errors = never();
    select str::sub(#start:0, #len:2, c) {
        "w " => {
            let v = str::sub(#start:2, #len:str::len(c) - 2, c)?;
            let v = str::parse(v)?;
            net::write(path, v)?
        },
        s => error("invalid command [s]")?
    };
    command_error <- errors
};
let command_mode = false;
let command = "";
let title_bottom = select command_mode {
    true => line(#style:style(#fg:`Cyan), ":[command]"),
    false => {
        let spans = [
            span("[path] ([selected_path])"),
            span(#style:style(#fg:`Red), "  [any(" ", command_error)]")
        ];
        line(#style:style(#fg:`Cyan), spans)
    }
};
let handle_key = |e: KeyCode| -> [`Stop, `Continue] select e {
    e@ `Left if !command_mode => {
        select e ~ selected.x {
            e if e <= 1 =>
                viewport <- uniq(e ~ { viewport with x: max(0, viewport.x - 1) }),
            e => selected <- e ~ { selected with x: selected.x - 1 }
        };
        `Stop
    },
    e@ `Right if !command_mode => {
        let limit = array::len(visible_columns);
        let clim = array::len(structure.columns) - array::len(visible_columns);
        select e ~ selected.x {
            x if x >= limit =>
                viewport <- uniq(x ~ { viewport with x: min(clim, viewport.x + 1) }),
            e => selected <- e ~ {selected with x: selected.x + 1}
        };
        `Stop
    },
    e@ `Down if !command_mode => {
        let rlim = array::len(structure.rows) - array::len(visible_rows);
        let limit = array::len(visible_rows) - 1;
        select e ~ selected.y {
            x if x >= limit =>
                viewport <- uniq(x ~ { viewport with y: min(rlim, viewport.y + 1) }),
            e => selected <- e ~ { selected with y: selected.y + 1 }
        };
        `Stop
    },
    e@ `Up if !command_mode => {
        select e ~ selected.y {
            e if e <= 0 =>
                viewport <- uniq(e ~ { viewport with y: max(0, viewport.y - 1) }),
            e => selected <- e ~ { selected with y: selected.y - 1 }
        };
        `Stop
    },
    e@ `Enter if !command_mode => {
        path <- e ~ (structure.rows)[selected.y]?;
        selected <- e ~ { x: 1, y: 0 };
        viewport <- e ~ { x: 0, y: 0 };
        `Stop
    },
    e@ `Backspace if !command_mode => select e ~ str::dirname(path) {
        null as _ => `Stop,
        s => {
            path <- s;
            selected <- s ~ { x: 1, y: 0 };
            viewport <- s ~ { x: 0, y: 0 };
            `Stop
        }
    },
    `Char(":") if !command_mode => {
        command <- "";
        command_error <- "";
        command_mode <- true;
        `Stop
    },
    `Char(c) if command_mode => {
        command <- c ~ "[command][c]";
        `Stop
    },
    e@ `Enter if command_mode => {
        command_mode <- false;
        run_command(command, e ~ selected_path);
        `Stop
    },
    e@ `Backspace if command_mode && (command != "") => {
        let len = str::len(command) - 1;
        command <- e ~ str::sub(#start:0, #len, command)?;
        `Stop
    },
    `Esc if command_mode => {
        command_mode <- false;
        `Stop
    },
    _ => `Continue
};
let handle_event = |e: Event| -> [`Stop, `Continue] select e {
    `Key(e) => handle_key(e.code),
    _ => `Continue
};
let grid = table(
    #cell_highlight_style:&style(#bg:`Yellow),
    #header:&header,
    #widths:&[],
    #flex:&`Center,
    #selected_cell: &selected,
    #style:&style(#bg:`Indexed(234)),
    &rows
);
let surround = block(
    #border:&`None,
    #border_style:&style(#fg:`Yellow),
    #title_bottom:&title_bottom,
    #size:&size,
    &grid
);
input_handler(#handle: &handle_event, &surround)
